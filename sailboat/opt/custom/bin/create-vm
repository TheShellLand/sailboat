#!/bin/bash
# SmartOS script creating VMs
#
# Provides an easy to use script for creating LX, OS, and KVM zones
# This de-encumbers the use of manual typing and creates json vm spec automatically
# Also, I stopped wanting to refer to an endless number of json files for figuring out what options to use for which
#  type of VM I was creating
#
#
# alpha1.1
# 0xB4AE7C4C Eric Jaw
#



function pre_check(){

  # Location for new VM specs
  SPECS_DIR="/opt/custom/json/SAVED_CUSTOM_VM"
  export SPECS_DIR
  echo "[*] New specs located in: $SPECS_DIR"
  if [ ! -d "$SPECS_DIR" ]; then mkdir -p "$SPECS_DIR"; fi
  echo ""

  # New temp file
  pre_check_temp
  return $?

}

function pre_check_temp(){

  # New temp filename
  TEMPSPEC="$(uuid).json"
  export TEMPSPEC
  TEMP="$SPECS_DIR/$TEMPSPEC"
  export TEMP
  echo "[*] This session: $TEMPSPEC"
  echo ""
  return $?

}


function choose_vm_type(){

  # LX, OS, or KVM
  echo "Select a VM type"
  select BRAND in "OS - Native, allows RAM over provisioning" "LX - Native, runs linux flavors, yum" "KVM - Linux image, Windows, Mac, any ISO"; do
    case $BRAND in
      "OS - Native, allows RAM over provisioning")
        echo ""
        create_vm joyent

        break ;;
      "LX - Native, runs linux flavors, yum")
        echo ""
        create_vm lx

        break ;;
      "KVM - Linux image, Windows, Mac, any ISO")
        echo ""
        create_vm kvm

        break ;;
    esac
  done
  
  # Initialize naming scheme
  new_vm_filename
  return $?

}

function create_vm(){

  BRAND="$1"
  export BRAND
  new_vm_filename $BRAND

  if [ "$BRAND" == joyent ]; then create_vm_os; return $?; fi
  if [ "$BRAND" == lx ]; then create_vm_lx; return $?; fi
  if [ "$BRAND" == kvm ]; then create_vm_kvm; return $?; fi
  return $?

}

function text_sanitize(){

  # Sanatizes input, removes all spaces, and non-alphanumeric charaters, also allows underscores
  # Used mainly for new_vm_filename()

  STRING="$@"
  CLEAN=${STRING// /}
  CLEAN=${CLEAN//[^a-zA-Z0-9_]/}
  output_sanatized="$CLEAN"
  export output_sanatized
  return $?

}

function new_vm_filename(){

  # Naming scheme for the new VM spec file: $BRAND_$ALIAS_$HOSTNAME_(link)(vnics).json
  #
  # (e.g. os__elasticdb__elastic0eshard0.json, kvm__win__windows10__nat0external0__sql0internal0.json)
  # All text will run though text_sanitize(); only characters allowed are regex [a-zA-Z0-9_]

  text_sanitize "$1"
  CHOMP="$output_sanatized"

  if [ "$CHOMP" == "JSONAAAAAA" ]; then VM_FILENAME="$VM_FILENAME".json; export VM_FILENAME
      export NEW_VM="$SPECS_DIR/$VM_FILENAME"; return $?; fi
  if [ -z "$CHOMP" ]; then VM_FILENAME=""; export VM_FILENAME; return $?; fi
  if [ -z "$VM_FILENAME" ]; then VM_FILENAME="$CHOMP"; export VM_FILENAME; return $?; fi
  if [ ! -z "$VM_FILENAME" ]; then VM_FILENAME="$VM_FILENAME"__"$CHOMP"; export VM_FILENAME; return $?; fi
  return $?

}


function spec_init(){

  cat > $TEMP << EOF
{
EOF
  return $?

}

function spec_brand(){

  #  global: brand
  #    This will be one of 'joyent' or 'joyent-minimal' for OS virtualization
  #    and 'kvm' for full hardware virtualization. This is a required value
  #    for VM creation.

  # Brand is received from create_vm()
  
  cat >> $TEMP << EOF
  "brand": "$BRAND",
EOF
  return $?

}

function spec_alias(){

  #  global: alias
  #    An alias for a VM which is for display/lookup purposes only. Not
  #    required to be unique.

  default=$(date +%s)

  read -p "Set VM alias (epoch: $default): " ALIAS
  if [ -z "$ALIAS" ]; then ALIAS=created-$default; fi
  echo ""
  
  cat >> $TEMP << EOF
  "alias": "$ALIAS",
EOF

  new_vm_filename "$ALIAS"
  return $?

}

function spec_hostname(){

  #  global: hostname
  #    For KVM VMs, this value will be handed out via DHCP as the hostname for
  #    the VM. For OS VMs, this value will get set in several files at
  #    creation time, but changing it later will do nothing.

  while true; do
    read -p "Set hostname: " HOSTNAME
    if [ -z "$HOSTNAME" ]; then echo "Please enter a hostname"
      else break; fi
  done
  echo ""

  cat >> $TEMP << EOF
  "hostname": "$HOSTNAME",
EOF

  new_vm_filename "$HOSTNAME"
  return $?

}

function spec_autoboot(){

  #  global: autoboot
  #    Boolean indicating that a zone should be booted automatically at
  #    system boot.  Note that if the zones service is disabled, the zone
  #    will not autoboot, regardless of the setting of this property. You
  #    enable the zones service with a svcadm command, such as:
  #
  #      svcadm enable svc:/system/zones:default

  default=false

  echo "Autoboot if SmartOS reboots? (This will crash the server if it runs out of resources!!)"
  select AUTOBOOT in "Yes" "No (default)"; do
    case $AUTOBOOT in
      Yes) 
        AUTOBOOT=true
      
        break ;;
      "No (default)")
        AUTOBOOT=false
      
        break ;;
    esac
  done
  echo ""
  
  cat >> $TEMP << EOF
  "autoboot": $AUTOBOOT,
EOF
  return $?

}

function spec_oslx_ram(){

  #  global: max_physical_memory
  #    The maximum amount of memory on the host that the VM is allowed to use.
  #    For KVM VMs, this value cannot be lower than ram and should be
  #    ram + 1024.

  default=128

  echo ::memstat | mdb -k
  echo ""
  echo "Select max RAM usage (in MB)"
  select RAM_MAX in "128" "256" "512" "1024" "2048" "4096" "Custom"; do
    case $RAM_MAX in
      128) 
        RAM_MAX=128
        
        break ;;
      256) 
        RAM_MAX=256
        
        break ;;
      512) 
        RAM_MAX=512
        
        break ;;
      1024) 
        RAM_MAX=1024
        
        break ;;
      2048) 
        RAM_MAX=2048
        
        break ;;
      4096) 
        RAM_MAX=4096
        
        break ;;
      Custom) 
        read -p "Custom max RAM usage (128): " RAM_MAX
        if [ -z "$RAM_MAX" ]; then RAM_MAX="$default"; fi
        break ;;
    esac
  done
  echo ""
  
  cat >> $TEMP << EOF
  "max_physical_memory": $RAM_MAX,
EOF
  return $?

}

function spec_oslx_cpu(){

  #  global: cpu_cap
  #    Sets a limit on the amount of CPU time that can be used by a VM. The
  #    unit used is the percentage of a single CPU that can be used by the VM.
  #    Eg. a value of 300 means up to 3 full CPUs.

  # OS VMs see all of the real CPUs, not some subset of them.
  # But scheduling reduces them to some set of their caps and shares.

  default=100

  echo "Select number of CPUs (a value of 300 means up to 3 full CPUs):"
  select CPU_CAP in "100 (default)" "200" "300" "400" "Custom"; do
    case $CPU_CAP in
      "100 (default)") 
        CPU_CAP=100
        
        break ;;
      200) 
        CPU_CAP=200
        
        break ;;
      300) 
        CPU_CAP=300
        
        break ;;
      400) 
        CPU_CAP=400
        
        break ;;
      Custom) 
        read -p "Custom CPU value (100): " CPU_CAP
        if [ -z "$CPU_CAP" ]; then CPU_CAP="$default"; fi
        break ;;
    esac
  done
  echo ""

  cat >> $TEMP << EOF
  "cpu_cap": $CPU_CAP,
EOF
  return $?

}


function spec_delegate_dataset(){

  #  os: delegate_dataset
  #     This property indicates whether we should delegate a ZFS dataset to an
  #     OS VM. If true, the VM will get a dataset <zoneroot dataset>/data (by
  #     default: zones/<uuid>/data) added to it. This dataset will be also be
  #     mounted on /<zoneroot dataset>/data inside the zone (again by default:
  #     /zones/<uuid>/data) but you can change this by setting the mountpoint
  #     option on the dataset from within the zone with zfs(1M). When using
  #     this option, sub-datasets can be created, snapshots can be taken and
  #     many other options can be performed on this dataset from within the
  #     VM.


  default=false

  echo "Delegate dataset?"
  select DELEGATE in "True" "False (default)"; do
    case $DELEGATE in
      True)
        DELEGATE=true

        break ;;
      "False (default)")
        DELEGATE=false

        break ;;
    esac
  done
  echo ""

  cat >> $TEMP << EOF
  "delegate_dataset": "$DELEGATE",
EOF
  return $?

}

function spec_oslx_disk(){

  #  global: quota
  #    This sets a quota on the zone filesystem. For OS VMs, this value is the
  #    space actually visible/usable in the guest. For KVM VMs, this value is
  #    the quota for the Zone containing the VM, which is not directly
  #    available to users.
  #
  #    Set quota to 0 to disable (ie. for no quota).


  default=5

  echo "Select disk size (in GB)"
  select QUOTA in "5 (default)" "10" "15" "20" "25" "30" "40" "Custom"; do
    case $QUOTA in
      "5 (default)") 
        QUOTA=5
        
        break ;;
      10) 
        QUOTA=10
        
        break ;;
      15) 
        QUOTA=15
        
        break ;;
      20) 
        QUOTA=20
        
        break ;;
      25) 
        QUOTA=25
        
        break ;;
      30) 
        QUOTA=30
        
        break ;;
      40) 
        QUOTA=40
        
        break ;;
      Custom) 
        read -p "Custom disk size (in GB) (5): " QUOTA
        if [ -z "$QUOTA" ]; then QUOTA="$default"; fi
        break ;;
    esac
  done
  echo ""
  
  cat >> $TEMP << EOF
  "quota": "$QUOTA",
EOF
  return $?

}

function spec_oslx_image(){

  #  os: image_uuid
  #    This should be a UUID identifying the image for the VM if a VM was
  #    created from an image.
  #    NOTE: when this is passed for KVM VMs, it specifies the *zone root*
  #    dataset which is not visible from within the VM. The user-visible
  #    dataset will be the one specified through the disks.*.image_uuid.
  #    Normally you do *not* want to set this for KVM.

  while true; do
    echo ""
    if [ "$BRAND" == joyent ]; then
      imgadm list -o uuid,name,version,os,type,published | grep -vw linux | grep -vw bsd | grep -vw other | grep -vw lx-dataset; fi

    if [ "$BRAND" == lx ]; then
      imgadm list -o uuid,name,version,os,type,published | grep -w lx-dataset; fi

      echo ""
      read -p "Select existing image: " IMAGE_UUID
      if [ -z "$IMAGE_UUID" ]; then echo "Missing UUID"
        else imgadm list | grep -w "$IMAGE_UUID" 2>/dev/null >/dev/null
          if [ $? == 0 ]; then break
            else echo "Image UUID does not exist. Check your spelling and try again"; sleep 2; fi
      fi
  done
  echo ""
  
  cat >> $TEMP << EOF
  "image_uuid": "$IMAGE_UUID",
EOF
  return $?

}

function spec_lx_kernel(){

  #  lx: kernel_version
  #    This sets the version of Linux to emulate for LX VMs

  default="3.13.0"

  echo "Select kernel version (setting an unsupported kernel version may cause instabilities in the VM)"
  select KERNEL_VERSION in "3.13.0" "Custom"; do
    case $KERNEL_VERSION in
      "3.13.0") 
        KERNEL_VERSION="3.13.0"
        
        break ;;
      Custom) 
        read -p "Custom kernel version (3.13.0): " KERNEL_VERSION
        if [ -z "$KERNEL_VERSION" ]; then KERNEL_VERSION="$default"; fi
        break ;;
    esac
  done
  echo ""

  cat >> $TEMP << EOF
  "kernel_version": "$KERNEL_VERSION",
EOF
  return $?

}

function spec_kvm_ram(){

  #  KVM: ram
  #    For KVM VMs this is the amount of virtual RAM that will be available to
  #    the guest kernel. For OS VMs this will be the same as the property
  #    max_physical_memory.

  default=512

  echo ::memstat | mdb -k
  echo ""
  echo "Select amount of RAM (in MB)"
  select RAM in "128" "256" "512" "1024" "2048" "4096" "5120" "6144" "Custom"; do
    case $RAM in
      128) 
        RAM=128
        
        break ;;
      256) 
        RAM=256
        
        break ;;
      512) 
        RAM=512
        
        break ;;
      1024) 
        RAM=1024
        
        break ;;
      2048) 
        RAM=2048
        
        break ;;
      4096) 
        RAM=4096
        
        break ;;
      5120) 
        RAM=5120
        
        break ;;
      6144) 
        RAM=6144
        
        break ;;
      Custom) 
        read -p "Custom RAM (512): " RAM
        if [ -z "$RAM" ]; then RAM="$default"; fi
        break ;;
    esac
  done
  echo ""

  cat >> $TEMP << EOF
  "ram": $RAM,
EOF
  return $?

}

function spec_kvm_cpu(){

  # KVM: vcpus
  #   KVM instances that says how many VCPUs they can see
  #   Which is independent of how much CPU the zone can actually use

  default=1

  echo "Select number of CPUs (Be sure not to use more cores than are available)"
  select VCPU in "1" "2" "3" "4" "Custom"; do
    case $VCPU in
      1) 
        VCPU=1
      
        break ;;
      2) 
        VCPU=2
      
        break ;;
      3) 
        VCPU=3
      
        break ;;
      4) 
        VCPU=4
        
        break ;;
      Custom) 
        read -p "Custom VCPUS (1): " VCPU
        if [ -z "$VCPU" ]; then VCPU="$default"; fi
        break ;;
    esac
  done
  echo ""

  cat >> $TEMP << EOF
  "vcpus": "$VCPU",
EOF
  return $?

}

function spec_kvm_disk(){

  #  KVM: disks.*.<property>
  #    When creating a KVM VM or getting a KVM VM's JSON, you will use this
  #    property. This is an array of 'disk' objects.

  default=blank

  echo "Select disk type"
  select KVM_DISK_TYPE in "Blank: New empty disk" "Image: Disk from an image"; do
    case $KVM_DISK_TYPE in
    "Blank: New empty disk") 
      KVM_DISK_TYPE="$default"
      
      break ;;
    "Image: Disk from an image") 
      KVM_DISK_TYPE=image
      
      break ;;
    esac
  done
  echo ""

  echo "Will this be the boot disk?"
  select BOOTABLE in "Yes (default)" "No"; do
    case $BOOTABLE in
      "Yes (default)")
        BOOTABLE=true
      
        break ;;
      No) 
        BOOTABLE=false
      
        break ;;
    esac
  done
  echo ""

  echo "Select disk model"
  select DISK_MODEL in "virtio (default)" "ide" "scsi"; do
    case $DISK_MODEL in
      "virtio (default)") 
        DISK_MODEL=virtio
      
        break ;;
      ide) 
        DISK_MODEL=ide
      
        break ;;
      scsi) 
        DISK_MODEL=scsi
      
        break ;;
    esac
  done
  echo ""

  echo "Select compression"
  select COMPRESSION in "on" "off (default)" "lzjb" "gzip" "gzip-N" "zle"; do
    case $COMPRESSION in
      on)
        COMPRESSION=on
      
        break ;;
      "off (default)")
        COMPRESSION=off
      
        break ;;
      lzjb) 
        COMPRESSION=lzjb
      
        break ;;
      gzip) 
        COMPRESSION=gzip
      
        break ;;
      gzip-N) 
        COMPRESSION="gzip-N"
      
        break ;;
      zle) 
        COMPRESSION=zle
      
        break ;;
    esac
  done  
  echo ""


  if [ "$KVM_DISK_TYPE" == blank ]; then
  echo "Select disk size (in MB)"
  select DISK_SIZE in "5120" "10240" "20480" "30720" "40960" "Custom"; do
    case $DISK_SIZE in
      5120) 
        DISK_SIZE=5120

        break ;;
      10240) 
        DISK_SIZE=10240

        break ;;
      20480) 
        DISK_SIZE=20480

        break ;;
      30720) 
        DISK_SIZE=30720

        break ;;
      40960) 
        DISK_SIZE=40960

        break ;;
      Custom) 
        read -p "Custom disk size (in MB) (10240): " DISK_SIZE
        if [ -z "$DISK_SIZE" ]; then DISK_SIZE=10240; fi
        break ;;
    esac
  done
    # Set zfs quota automatically from disk size
    QUOTA=$(($DISK_SIZE / 1024 + 1))
  fi
  echo ""

  if [ "$KVM_DISK_TYPE" == image ]; then
  while true; do
    echo ""
    imgadm list -o uuid,name,version,os,type,published | grep -vw other | grep -vw lx-dataset | grep -vw smartos
    echo ""
    read -p "Select existing image: " IMAGE_UUID
    if [ -z "$IMAGE_UUID" ]; then echo "Missing UUID"
      else imgadm list | grep -w "$IMAGE_UUID" 2>/dev/null >/dev/null
        if [ $? == 0 ]; then break
          else echo "Image UUID does not exist. Check your spelling and try again"; sleep 2; fi
    fi
  done
  echo ""

  while true; do
    echo ""
    imgadm list -o uuid,name,version,os,type,published | grep -vw other | grep -vw lx-dataset | grep -vw smartos
    echo ""
    read -p "Image name: " IMAGE_NAME
    if [ -z "$IMAGE_NAME" ]; then echo "Missing image name"
      else imgadm list | grep -w "$IMAGE_NAME" 2>/dev/null >/dev/null
        if [ $? == 0 ]; then break
          else echo "Image name does not exist. Check your spelling and try again"; sleep 2; fi
    fi
  done
  echo ""

  echo "Select max disk allocation (in MB)"
  select IMAGE_SIZE in "10240" "20480" "30720" "40960" "Custom"; do
    case $IMAGE_SIZE in
      10240) 
        IMAGE_SIZE=10240
        
        break ;;
      20480) 
        IMAGE_SIZE=20480
         
        break ;;
      30720) 
        IMAGE_SIZE=30720
         
        break ;;
      40960) 
        IMAGE_SIZE=40960
        
        break ;;
      Custom) 
        read -p "Custom disk size (in MB): " IMAGE_SIZE
      
        break ;;
    esac
  done
    # Set zfs quota automatically from disk size
    QUOTA=$(($IMAGE_SIZE / 1024))
  fi
  echo ""

  # JSON
  if [ -z "$1" ]; then
    cat >> $TEMP << EOF
  "quota": "$QUOTA",
  "disks": [
EOF
  fi


  # JSON
  if [ "$KVM_DISK_TYPE" == blank ]; then
    cat >> $TEMP << EOF
    {
      "boot": $BOOTABLE,
      "model": "$DISK_MODEL",
      "compression": "$COMPRESSION",
      "size": $DISK_SIZE
EOF
  fi

  # JSON
  if [ "$KVM_DISK_TYPE" == image ]; then
    cat >> $TEMP << EOF
    {
      "boot": $BOOTABLE,
      "model": "$DISK_MODEL",
      "compression": "$COMPRESSION",
      "image_uuid": "$IMAGE_UUID",
      "image_name": "$IMAGE_NAME"
EOF
  fi

  echo "Add another Disk?"
  select ANSWER in "Yes" "No (default)"; do
    case $ANSWER in
      "Yes")
        cat >> $TEMP << EOF
    },
EOF
        echo ""
        spec_kvm_disk 1
        break ;;
      "No (default)")
        cat >> $TEMP << EOF
    }
  ],
EOF
        break ;;
    esac
  done
  echo ""
  return $?

}

function spec_kvm_iso_copy(){

  # Selects and copies an ISO to the KVM root for booting
  # e.g. Windows

  # Optional: Attaching virtio driver iso

  ISOS=/opt/custom/iso
  ISO=($(ls "$ISOS" | grep .iso))
  VIRTIOS=$ISOS/virtio
  VIRTIO=($(ls "$VIRTIOS" | grep .iso))

  if [ ! -d "$ISOS" ]; then mkdir -p "$ISOS"; fi
  if [ ! -d "$VIRTIOS" ]; then mkdir -p "$VIRTIOS"; fi

  ls -l "$ISOS" | grep ^[-] 2>/dev/null >/dev/null
  if [ $? == 1 ]; then echo "[!] No ISO found in $ISOS"; echo ""; return $?; fi

  ls -l "$VIRTIOS" | grep ^[-] 2>/dev/null >/dev/null
  if [ $? == 1 ]; then echo "[!] No virtio drivers found in $VIRTIOS"; echo ""; fi

  while true; do
    echo ""
    #vmadm list
    read -p "Set UUID of the new VM: " UUID
    export UUID
    if [ ! -z "$UUID" ]; then vmadm list | grep -w "$UUID"
      if [ $? == 0 ]; then break
        else echo "UUID not found. Check spelling and try again"; fi
    fi
  done
  echo ""

  echo "Select an ISO"
  select ANSWER in "${ISO[@]}"; do
    ISO="$ANSWER"
    echo ""
    echo Copying "$ISO" "==>" /zones/"$UUID"/root/
    echo ""
    rsync -ih --progress $ISOS/"$ISO" /zones/"$UUID"/root/
    break
  done
  echo ""

  echo "Boot?"
  select ANSWER in "Yes" "No"; do
    case $ANSWER in
      Yes)
        echo ""
        echo "Attach virtio ISO?"
        select ANSWER in "Yes" "No"; do
          case $ANSWER in
            Yes)
              echo ""
              echo "Select virtio iso"
              select ANSWER in "${VIRTIO[@]}"; do
                VIRTIO="$ANSWER"
                echo ""
                echo Copying "$VIRTIO" "==>" /zones/"$UUID"/root/
                echo ""
                rsync -ih --progress $VIRTIOS/"$VIRTIO" /zones/"$UUID"/root/
                echo "[*] vmadm start "$UUID" order=cd,once=d cdrom=/"$ISO",ide cdrom=/"$VIRTIO",ide"
                vmadm start "$UUID" order=cd,once=d cdrom=/"$ISO",ide cdrom=/"$VIRTIO",ide
                break
              done
              break ;;

            No) break ;;
          esac
        done

        echo "[*] vmadm start "$UUID" order=cd,once=d cdrom=/"$ISO",ide"
        vmadm start "$UUID" order=cd,once=d cdrom=/"$ISO",ide
        break ;;
      No) break ;;
    esac
  done
  echo ""

  return $?

}

function kvm_vnc(){
  
  #  KVM: vnc_password
  #    This property allows you to set a password which will be required when
  #    connecting to the VNC port. IMPORTANT: this password will be visible
  #    from the GZ of the CN and anyone with access to the serial port in the
  #    guest. Set to an empty string (default) to not require a password at
  #    this level.
  #
  #     string (8 chars max)

  while true; do
    read -sp "VNC Password (8 chars max): " VNC_PASS
    if [ -z "$VNC_PASS" ]; then echo "Please enter a password"; else break; fi
  done

  vmadm update "$UUID" <<EOF
{
  "vnc_password": "$VNC_PASS"
}
EOF
  return $?

}


function spec_nics(){

  ### All properties also follow nic.*.<property>
  #
  #  global: interface
  #    Name of the interface within the VM ("net0")
  #    This is also set automatically
  #
  #  global: nic_tag
  #    nic_tag or interface name that the virtual NIC is attached to
  #    This option for a NIC determines which host NIC the VMs nic will be
  #    attached to. The value can be either a nic tag as listed in the 'NIC
  #    Names' field in `sysinfo`, or an etherstub or device name.
  #
  #  KVM: model
  #    Driver for this NIC (virtio, e1000, rtl8139)
  #
  #  global: ip
  #    IPv4 Address for NIC, or "dhcp"
  #
  #  global: gateway
  #    Gateway for NIC
  #
  #  global: netmask
  #    Netmask for NIC
  #
  #  global: primary
  #    Sets this NICs gateway as the default gw
  #
  ### Advanced nic configuration ###
  #
  #  global: allow_dhcp_spoofing
  #    With this property set to true, this VM will be able to operate as a
  #    DHCP server on this interface.  Without this, some of the packets
  #    required of a DHCP server will not get through.
  #  
  #  global: allow_ip_spoofing
  #    With this property set to true, this VM will be able to send and
  #    receive packets over this nic that don't match the IP address
  #    specified by the ip property.
  #
  #  global: allow_mac_spoofing
  #     With this property set to true, this VM will be able to send packets
  #     from this nic with MAC addresses that don't match the mac property.
  #
  #  global: allow_restricted_traffic
  #     With this property set to true, this VM will be able to send
  #     restricted network traffic (packets that are not IPv4, IPv6, or ARP)
  #     from this nic.
  #
  #  KVM: allow_unfiltered_promisc
  #    With this property set to true, this VM will be able to have multiple
  #    MAC addresses (eg. running SmartOS with VNICs).  Without this option
  #    these packets will not be picked up as only those unicast packets
  #    destined for the VNIC's MAC will get through.  Warning: do not enable
  #    this option unless you fully understand the security implications.
  #
  #  global: blocked_outgoing_ports
  #    Array of ports on which this nic is prevented from sending traffic.
  #
  #  global: allowed_ips
  #    This sets additional IP addresses from which this nic is allowed to
  #    send traffic, in addition to the IPs in the ip and vrrp_primary_ip
  #    properties (if set). Values can be either single IPv4 Addresses or
  #    CIDR ranges in the form 192.168.1.0/24.
  #
  #  global: dhcp_server
  #    With this property set to true, this VM will be able to operate as a
  #    DHCP server on this interface.  Without this, some of the packets
  #    required of a DHCP server will not get through.



  INTERFACE_default=net0
  NICTAG_default=external
  MTU_default=1500
  IPADDRESS_default=unset
  GATEWAY_default=unset
  NETMASK_default=unset
  PRIMARY_default=unset



  while true; do
  
    # Removing this in future release, since interface is can be automatically created
    #read -p "Set VM internal NIC name (net0): " INTERFACE
    #if [ -z "$INTERFACE" ]; then INTERFACE=$INTERFACE_default; fi
    #echo ""

    echo "Select NIC type to use"
    select ANSWER in "NIC tag (default)" "etherstub"; do
      case $ANSWER in
        "NIC tag (default)")
          while true; do
            echo ""
            nictagadm list | head -1; nictagadm list | grep normal
            read -p "Set NIC tag for traffic to go over (external): " NICTAG
            if [ -z "$NICTAG" ]; then NICTAG=$NICTAG_default; fi
            if [ ! -z "$NICTAG" ]; then nictagadm list | grep -w "$NICTAG" 2>/dev/null >/dev/null
              if [ $? == 0 ]; then break
                else echo "NIC tag not found. Check spelling and try again"; fi
            fi
          done

          break ;;
          # Removing VNICS, SmartOS only allows nic tags and etherstubs
#        "virtual NIC")
#          while true; do
#            echo ""
#            dladm show-vnic
#            read -p "Set virtual NIC: " NICTAG
#            if [ -z "$NICTAG" ]; then echo "You must enter in a virtual NIC"; sleep 2
#              else dladm show-vnic | grep -w "$NICTAG" 2>/dev/null >/dev/null
#                if [ "$?" == 0 ]; then break
#                  else echo "Virtual NIC not found. Check spelling and try again"; fi
#            fi
#          done
##
#          break ;;
        etherstub)
          while true; do
            echo ""
            dladm show-etherstub
            read -p "Set etherstub: " NICTAG
            if [ -z "$NICTAG" ]; then echo "You must enter an etherstub"; sleep 2
              else dladm show-etherstub | grep -w "$NICTAG" 2>/dev/null >/dev/null
                if [ "$?" == 0 ]; then break
                  else echo "Etherstub not found. Check spelling and try again"; fi
            fi
          done

          break ;;
      esac
    done
    echo ""

    if [ -z "$PRIMARY_count" ]; then
      echo "Set NIC as default gw?"
      select ANSWER in "Yes (default)" "No"; do
        case $ANSWER in
          "Yes (default)")
            PRIMARY=true
            let PRIMARY_count++
            break ;;
          "No")
            PRIMARY=false

            break ;;
        esac
      done
      echo ""
    else
      PRIMARY=false
    fi

    echo "MTU"
    select ANSWER in "1500 (default)" "Custom"; do
      case $ANSWER in
        "1500 (default)")
          MTU=1500
          break ;;
        "Custom")
          while true; do
            read -p "MTU (1500): " MTU
            if [ -z "$MTU" ]; then MTU=1500; break; fi
          done
          break ;;
      esac
    done
    echo ""

    echo "Set addressing type"
    select ANSWER in "DHCP (default)" "Static"; do
      case $ANSWER in
        "DHCP (default)")
          IPADDRESS=dhcp
          break ;;
        "Static")
          while true; do
            read -p "IPv4: " IPADDRESS
            if [ -z "$IPADDRESS" ]; then echo "You must enter an IP"
              else break; fi
          done

          while true; do
            read -p "Gateway: " GATEWAY
            if [ -z "$GATEWAY" ]; then echo "You must enter a gateway IP"
              else break; fi
          done

          read -p "Netmask (255.255.255.0): " NETMASK
          if [ -z "$NETMASK" ]; then NETMASK="255.255.255.0"; fi

          break ;;
      esac
    done
    echo ""

    if [ "$BRAND" == kvm ]; then
      echo "Choose NIC Model: (virtio: best performance, but needs drivers; e1000 & rtl8139: more universal) "
      select ANSWER in "virtio (default)" "e1000" "rtl8139"; do
        case $ANSWER in
          "virtio (default)")
            NICMODEL="virtio"

            break ;;
          e1000)
            NICMODEL="e1000"

            break ;;
          rtl8139)
            NICMODEL="rtl8139"

            break ;;
        esac
      done; fi
      echo ""

    ### Advanced nic configurations ###

  #  global: dhcp_server
  #    With this property set to true, this VM will be able to operate as a
  #    DHCP server on this interface.  Without this, some of the packets
  #    required of a DHCP server will not get through.
  #
  #  global: allow_dhcp_spoofing
  #    With this property set to true, this VM will be able to operate as a
  #    DHCP server on this interface.  Without this, some of the packets
  #    required of a DHCP server will not get through.

    echo "Allow DHCP Spoofing?"
    select ANSWER in "Yes" "No (default)"; do
      case $ANSWER in
        Yes)
          DHCP=true
          DHCP_SPOOF=true

          break ;;
        "No (default)")
          DHCP=false
          DHCP_SPOOF=false

          break ;;
      esac
    done
    echo ""

  #
  #  global: allow_ip_spoofing
  #    With this property set to true, this VM will be able to send and
  #    receive packets over this nic that don't match the IP address
  #    specified by the ip property.

    echo "Allow IP Spoofing?"
    select ANSWER in "Yes" "No (default)"; do
      case $ANSWER in
        Yes)
          IP_SPOOF=true

          break ;;
        "No (default)")
          IP_SPOOF=false

          break ;;
      esac
    done
    echo ""

  #  global: allow_mac_spoofing
  #     With this property set to true, this VM will be able to send packets
  #     from this nic with MAC addresses that don't match the mac property.

    echo "Allow MAC Spoofing?"
    select ANSWER in "Yes" "No (default)"; do
      case $ANSWER in
        Yes)
          MAC_SPOOF=true

          break ;;
        "No (default)")
          MAC_SPOOF=false

          break ;;
      esac
    done
    echo ""

  #  global: allow_restricted_traffic
  #     With this property set to true, this VM will be able to send
  #     restricted network traffic (packets that are not IPv4, IPv6, or ARP)
  #     from this nic.
  #
  #  KVM: allow_unfiltered_promisc
  #    With this property set to true, this VM will be able to have multiple
  #    MAC addresses (eg. running SmartOS with VNICs).  Without this option
  #    these packets will not be picked up as only those unicast packets
  #    destined for the VNIC's MAC will get through.  Warning: do not enable
  #    this option unless you fully understand the security implications.
  #
  #  global: blocked_outgoing_ports
  #    Array of ports on which this nic is prevented from sending traffic.
  #
  #  global: allowed_ips
  #    This sets additional IP addresses from which this nic is allowed to
  #    send traffic, in addition to the IPs in the ip and vrrp_primary_ip
  #    properties (if set). Values can be either single IPv4 Addresses or
  #    CIDR ranges in the form 192.168.1.0/24.

    ### END Advanced nic configurations ###

    echo "[!] Your Configuration"
    #echo ">> Interface:" "$INTERFACE"
    echo "{-} NIC Tag:" "$NICTAG"
    echo "{-} MTU:" "$MTU"
    if [ "$BRAND" == kvm ]; then echo "{-} NIC Model:" "$NICMODEL"; fi
    echo "{-} IPv4:" "$IPADDRESS"
    if [ ! "$IPADDRESS" == dhcp ]; then echo "{-} Gateway:" "$GATEWAY"; fi
    if [ ! "$IPADDRESS" == dhcp ]; then echo "{-} Netmask:" "$NETMASK"; fi
    echo "{-} Primary NIC:" "$PRIMARY"
    if [ ! -z "$DHCP" ]; then echo "{-} DHCP: " "$DHCP"; fi
    if [ ! -z "$DHCP_SPOOF" ]; then echo "{-} DHCP Spoofing: " "$DHCP_SPOOF"; fi
    if [ ! -z "$IP_SPOOF" ]; then echo "{-} IP Spoofing: " "$IP_SPOOF"; fi
    if [ ! -z "$MAC_SPOOF" ]; then echo "{-} MAC Spoofing: " "$MAC_SPOOF"; fi


    echo ""
    echo "Confirm?"
    select ANSWER in "Done" "There's something wrong"; do
      case $ANSWER in
        "Done") 
          FINISHED="true"
        
          break ;;
        "There's something wrong") 
          FINISHED="false"
        
          break ;;
      esac
    done

    new_vm_filename "$IPADDRESS""$NICTAG"

    if [ "$FINISHED" == true ]; then break; fi
  done
  echo ""


  # JSON
  if [ -z "$1" ]; then
cat >> $TEMP << EOF
  "nics": [
EOF
  fi

  # JSON
  if [ "$BRAND" == joyent ]; then
    if [ "$IPADDRESS" == dhcp ]; then
      cat >> $TEMP << EOF
    {
      "nic_tag": "$NICTAG",
      "mtu": "$MTU",
      "ip": "$IPADDRESS",
      "dhcp_server": $DHCP,
      "allow_dhcp_spoofing": $DHCP_SPOOF,
      "allow_ip_spoofing": $IP_SPOOF,
      "allow_mac_spoofing": $MAC_SPOOF,
      "primary": $PRIMARY
EOF
    else
      cat >> $TEMP << EOF
    {
      "nic_tag": "$NICTAG",
      "mtu": "$MTU",
      "ip": "$IPADDRESS",
      "gateway": "$GATEWAY",
      "netmask": "$NETMASK",
      "dhcp_server": $DHCP,
      "allow_dhcp_spoofing": $DHCP_SPOOF,
      "allow_ip_spoofing": $IP_SPOOF,
      "allow_mac_spoofing": $MAC_SPOOF,
      "primary": $PRIMARY
EOF
  fi; fi

  # JSON
  if [ "$BRAND" == lx ]; then
    if [ "$IPADDRESS" == dhcp ]; then
      cat >> $TEMP << EOF
    {
      "nic_tag": "$NICTAG",
      "mtu": "$MTU",
      "ip": "$IPADDRESS",
      "dhcp_server": $DHCP,
      "allow_dhcp_spoofing": $DHCP_SPOOF,
      "allow_ip_spoofing": $IP_SPOOF,
      "allow_mac_spoofing": $MAC_SPOOF,
      "primary": $PRIMARY
EOF
    else
      cat >> $TEMP << EOF
    {
      "nic_tag": "$NICTAG",
      "mtu": "$MTU",
      "ip": "$IPADDRESS",
      "gateway": "$GATEWAY",
      "netmask": "$NETMASK",
      "dhcp_server": $DHCP,
      "allow_dhcp_spoofing": $DHCP_SPOOF,
      "allow_ip_spoofing": $IP_SPOOF,
      "allow_mac_spoofing": $MAC_SPOOF,
      "primary": $PRIMARY
EOF
  fi; fi

  # JSON
  if [ "$BRAND" == kvm ]; then
    if [ "$IPADDRESS" == dhcp ]; then
      cat >> $TEMP << EOF
    {
      "nic_tag": "$NICTAG",
      "mtu": "$MTU",
      "model": "$NICMODEL",
      "ip": "$IPADDRESS",
      "dhcp_server": $DHCP,
      "allow_dhcp_spoofing": $DHCP_SPOOF,
      "allow_ip_spoofing": $IP_SPOOF,
      "allow_mac_spoofing": $MAC_SPOOF,
      "primary": $PRIMARY
EOF
    else
      cat >> $TEMP << EOF
    {
      "nic_tag": "$NICTAG",
      "mtu": "$MTU",
      "model": "$NICMODEL",
      "ip": "$IPADDRESS",
      "gateway": "$GATEWAY",
      "netmask": "$NETMASK",
      "dhcp_server": $DHCP,
      "allow_dhcp_spoofing": $DHCP_SPOOF,
      "allow_ip_spoofing": $IP_SPOOF,
      "allow_mac_spoofing": $MAC_SPOOF,
      "primary": $PRIMARY
EOF
  fi; fi

  echo "Add another NIC?"
  select ANSWER in "Yes" "No (default)"; do
    case $ANSWER in
      "Yes")
        cat >> $TEMP << EOF
    },
EOF
        echo ""
        spec_nics 1
        break ;;
      "No (default)")
        cat >> $TEMP << EOF
    }
  ],
EOF
        break ;;
    esac
  done
  echo ""
  return $?

}

function spec_dns(){

  #  global: resolvers
  #    For OS VMs, this value sets the resolvers which get put into
  #    /etc/resolv.conf at VM creation. If maintain_resolvers is set to
  #    true, updating this property will also update the resolvers in
  #    /etc/resolv.conf. For KVM VMs these will get passed as the resolvers
  #    with DHCP responses.

  default=(8.8.8.8 8.8.4.4)

  echo "Select a DNS"
  select DNS in "8.8.8.8, 8.8.4.4" "Custom"; do
    case $DNS in
      "8.8.8.8, 8.8.4.4")
        DNS_PRIMARY="8.8.8.8"; DNS_SECONDARY="8.8.4.4"

        break ;;
      Custom)
        read -p "Set Primary DNS (8.8.8.8): " DNS_PRIMARY
        read -p "Set Secondary DNS (8.8.4.4): " DNS_SECONDARY

        if [ -z "$DNS_PRIMARY" ]; then DNS_PRIMARY="${default[0]}"; fi
        if [ -z "$DNS_SECONDARY" ]; then DNS_SECONDARY="${default[1]}"; fi

        break ;;
    esac
  done
  echo ""

#  while true; do
#    read -p "Enter DNS domain: " DNS_DOMAIN
#    if [ -z "$DNS_DOMAIN" ]; then echo "Please enter a dns domain"
#      else break; fi
#  done
#  "dns_domain": "$DNS_DOMAIN",

  cat >> $TEMP << EOF
  "resolvers": [
    "$DNS_PRIMARY",
    "$DNS_SECONDARY"
  ]
EOF
  echo "[*] DNS: $DNS_PRIMARY, $DNS_SECONDARY"
  echo ""
  return $?

}

function spec_ssh(){

  #  global: customer_metadata
  #    This field allows metadata to be set and associated with this VM. The
  #    value should be an object with only top-level key=value pairs.

  SSH=/opt/custom/ssh-keys

  if [ ! -d "$SSH" ]; then mkdir -p "$SSH"; fi

  ls -l "$SSH" | grep ^[-] 2>/dev/null >/dev/null
  if [ $? == 1 ]; then echo "[!] No ssh keys found in $SSH"; echo ""; return $?; fi

  echo "Add ssh key?"
  select ANSWER in "Yes" "No"; do
    case $ANSWER in
      Yes)
        while true; do
          echo ""
          echo "Existing public keys:"
          select ANSWER in $(ls $SSH); do
            ROOT_AUTHORIZED_KEYS=$(cat "$SSH/$ANSWER")
            break
          done
          break
        done
        break ;;
      No) echo ""; return $? ;;
    esac
  done
  echo ""

  cat >> $TEMP << EOF
  "customer_metadata": {
    "root_authorized_keys": "$ROOT_AUTHORIZED_KEYS",
    "user-script" : "/usr/sbin/mdata-get root_authorized_keys > ~root/.ssh/authorized_keys; chmod 600 ~root/.ssh/authorized_keys"
  },
EOF
  return $?

}


function spec_end(){

  cat >> $TEMP << EOF
}
EOF

  new_vm_filename JSONAAAAAA
  return $?

}

function os(){

  spec_init
  spec_brand
  spec_alias
  spec_hostname
  spec_autoboot
  spec_oslx_ram
  spec_oslx_cpu
  spec_delegate_dataset
  spec_oslx_disk
  spec_oslx_image
  spec_nics
  spec_ssh
  spec_dns
  spec_end
  return $?

}

function lx(){

  spec_init
  spec_brand
  spec_alias
  spec_hostname
  spec_autoboot
  spec_lx_kernel
  spec_oslx_ram
  spec_oslx_cpu
  spec_delegate_dataset
  spec_oslx_disk
  spec_oslx_image
  spec_nics
  spec_ssh
  spec_dns
  spec_end
  return $?

}

function kvm(){

  spec_init
  spec_brand
  spec_alias
  spec_hostname
  spec_autoboot
  spec_kvm_ram
  spec_kvm_cpu
  spec_kvm_disk
  spec_nics
  spec_ssh
  spec_dns
  spec_end
  return $?

}


function vmadm_validate(){

  # Validates the new vm spec before renaming to $VM_FILENAME
  vmadm validate create -f "$TEMP" >/dev/null 2>/dev/null
  # exit code check
  if [ $? == 0 ]; then echo "[*] JSON Validated"; mv "$TEMP" "$NEW_VM"
    else echo "[ERROR] Validating $TEMPSPEC"; exit 1; fi
  return $?

}

function vmadm_create(){

  # Create VM from $TEMP
  vmadm create -f "$NEW_VM"
  echo ""
  return $?

}

function info(){

  while true; do
    if [ -z "$UUID" ]; then
      read -p "Enter new VM UUID: " UUID
      export UUID
    fi
    vmadm list | grep -w "$UUID" 2>/dev/null >/dev/null
      if [ $? == 0 ]; then break
        else echo "UUID not found. Please check spelling and try again"; fi
  done

  while true; do
    vmadm start "$UUID"
    while true; do
      echo "[*] Awaiting network"
      if [ "$BRAND" == joyent ]; then
        echo ""
        echo "[*] ipadm show-addr"
        zlogin "$UUID" ipadm show-addr
        echo ""
        echo "[*] netstat -rn"
        zlogin "$UUID" netstat -rn; fi
      if [ "$BRAND" == lx ]; then
        echo ""
        echo "[*] /sbin/ip a"
        zlogin "$UUID" /sbin/ip a
        echo ""
        echo "[*] /bin/netstat -rn"
        zlogin "$UUID" /bin/netstat -rn; fi
      if [ "$BRAND" == kvm ]; then
        echo ""
        echo "[*] VNC"
        vmadm info "$UUID" vnc; fi
      echo ""
      read -p "Press enter to refresh network lookup, or type quit " ANSWER
      if [ "$ANSWER" == quit ]; then break; fi
    done
    break
  done
  echo ""
  return $?

}

function create_vm_os(){

  os
  vmadm_validate
  vmadm_create
  info
  return $?

}

function create_vm_lx(){

  lx
  vmadm_validate
  vmadm_create
  info
  return $?

}

function create_vm_kvm(){

  kvm
  vmadm_validate
  vmadm_create
  echo ""
  echo "Would you like to boot from an ISO?"
  select ANSWER in "Yes" "No"; do
    case $ANSWER in
      Yes)
        spec_kvm_iso_copy

        break ;;
      No) break ;;
    esac
  done
  info
  kvm_vnc
  return $?

}


function happy_term(){

clear

print '
ICAgICAgICAgICAgIC4ueis6KysrOjo7Kys6OisrKysrKzo6OisrOjorKzo6Ojor
KysremF6dWdtSiwuCiAgICAgICAgIC4sNys6Oi5KK0orP0p1eEpRZ0hISEhtUWdn
bWErSkp4LEomJitKSm1tU3l3WGsxK3pUSEgmLAogICAgICAgLDo/aSsuZFdPV0hI
SEhISEhISEhISEhISEhIQkI5VVRZOj8rVFdZWVdISEhISEhuKz9YZSs/VDo/Li4K
ICAgIC5KOjo/d1hnWFdIbW1tbW1tbW1tbW1tbUhXbW1tSEk6OjM6Ojo6Ojo6Ojo6
Pz9XSG1tbWdtV1htSFNpLDo/Ky4KICAgLDo6Lit4WVkkV1dBJldQZGhYbW1tbW1t
bW1tSEg5PUorOjo6Ojo6Ojo6Ojo6Ojo6Sm1tbWdtSFFXSEM6Ojo6OjppCiAgKzo6
P2pRa2srK3o/UW1tSEhtbW1tbW1tbW1tbVo/ejc6Ojo6Ojo6Ojo6XjpeOjpeOjo/
VUhtbW1tbUsrOjo6Xjo6OisuCiArOj9kSG1tbW1tbW1LV21SZFlZSG1nbW1nbWdt
QkM/Ojo6Ojo6XjpeOjpeOjo6Ol46Ojo6Oj9YSEs6Oj8rLDo6Ojo6OjorCi46Okpt
bW1nbW1tbW1ISm1CMzo6P0g5Oj9UbW06Ong6Ojo6Xjo6Ojo6Ojo6OjorOjo6Ol46
Ojo6P1Q2WCs/Pz0rLl46Ojo6OgorOjo/SEhISG1tZ21tbUhrOjo6Ojo/Yzo6Pys9
Oj9qYzo6Xjo6OjpeOjo6Xjo6Xjo6Xjo6Ojo6Ojo6Ojo/K2prUW0sLl46OisKbDo6
Ojo6Oj9XbW1tbWc5Ojo6Ojo6Ojo6Oj9YSlhEeCsrSiw6Ljo6Ol46Ojo6Xjo6Ojo6
Ol46Xjo6Ojo6Oj9YbW1tbVIrLDo/Cjo6Xjo6Ojo6P0hnbW1IKzo6Ol46Ol46Ojo6
Oj8xOz86Kz9ZMzorKzo6OjpeOjo6Xjo6Xjo6OjpeOl46Ojo/V21tbW1tbW1EPwou
Ojo6Xjo6Oj9IbW1nIz1qSTo6Ojo6Xjo6Ojo6OjpKUW1tZHg6OjorOj86Ojo6Ojo6
Xjo6Ol46Ojo6Xjo6Oj9XbWdtbW1EOjoKICs6OjpeOjo6P0htbUQ6Pzo6Ol46Ojo6
Ol46Xj9IbW1tbW1xczo6Ojo6OjpeOjo6Ojo6Xjo6Ojo6Ojo6Xjo/V21nSFkrOj8K
ICArOjo6Ol46Oj9UWSs6OjpeOjo6Ol46Ojo6Ojo/WT0/VEhtMzo6Xis6Ol46Ol46
Xjo6Ojo6XjpeOjo6OkpkbUJZOjo6P2AKICAgOi46Ojo6Ojo6Ojo6Ojo6Ojo6Xjo6
OjpeOjo6Ojo6OjorOjo6Sjc6Ojo6Ojo6Ol46Ol46Ojo6Xjo6SkgzKzo6Ojo/CiAg
ICAuKy46Xjo6Ojo6OjpeOjpeOjorOjpeOjo6Ojo6Ojo6Ol46Ojo6Ojo6Xjo6Xjo6
Ojo6Xjo6OjouZDMrOjouOj8hCiAgICAgICAhLDpeOjpeOjo6Xjo6Ojo6Ojo6Ojo6
Xjo6Xjo6Xjo6Ojo6OjpeOjo6Ojo6Xjo6OjpeOjo6Ljo6Oi4/YAogICAgICAgICBg
IS46SisrSisrYVFXSFFhJldXV0hxSEhxSG1nYUo6Xjo6OjpeOi4uLi5KPz8/K0o6
OjouPyEKICAgICAgICAgICAgID9UV0htbW1tbW1tbW1tbW1tbW1tbW1tbW0rSkpK
alhIbXFxcXFtbW1xSEgwNyFgICAgICAgICAgIG1jCgpXZWxjb21lIHRvIFNtYXJ0
T1MgVGVybWluYWwKCgoK'\
| openssl enc -base64 -d

  return $?

}




# MAIN

happy_term
pre_check

choose_vm_type

