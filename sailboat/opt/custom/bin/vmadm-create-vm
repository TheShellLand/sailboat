#!/bin/sh
# SmartOS script creating VMs
#
# Provides an easy to use script for creating LX, OS, and KVM zones
# This de-encumbers the use of manual typing and creates json vm spec automatically
# Also, I stopped wanting to refer to an endless number of json files for figuring out what options to use for which
#  type of VM I was creating
#
#
# alpha0.1
# 0xB4AE7C4C
#


function _EasyTiger(){

  export DIFFICULTY=$1

  choose_vm_type
  return $?

}


function pre_check(){

  # Location for new VM specs
  SPECS_DIR="/opt/custom/json/SAVED_CUSTOM_VM"
  export SPECS_DIR
  echo "[*] New specs located in: $SPECS_DIR"
  if [ ! -d "$SPECS_DIR" ]; then mkdir -p "$SPECS_DIR"; fi

  # New temp file
  pre_check_temp
  return $?

}
function pre_check_temp(){

  # New temp filename
  TEMPSPEC="$(uuid).temp.json"
  export TEMPSPEC
  TEMP="$SPECS_DIR/$TEMPSPEC"
  export TEMP
  return $?

}


function choose_vm_type(){

  # LX, OS, or KVM
  echo "Select a VM type"
  select type in "OS - Native, allows RAM over provisioning" "LX - Native, runs linux flavors, yum" "KVM - Linux image" "ISO - Windows, Linux, Mac, any ISO"; do
    case option in
      "OS - Native, allows RAM over provisioning") create_vm os ; return $? ;;
      "LX - Native, runs linux flavors, yum") create_vm lx; return $? ;;
      "KVM - Linux image") create_vm kvm; return $? ;;
      "ISO - Windows, Linux, Mac, any ISO") create_vm iso; return $? ;;
    esac
  done
  return $?

}


function create_vm(){

  TYPE="$1"
  export TYPE

  if [ "$TYPE" == "os" ]; then create_vm_os; return $?; fi
  if [ "$TYPE" == "lx" ]; then create_vm_lx; return $?; fi
  if [ "$TYPE" == "iso" ]; then create_vm_iso; return $?; fi
  if [ "$TYPE" == "kvm" ]; then create_vm_kvm; return $?; fi
  return $?

}


function text_sanitize(){

  # Sanatizes input, removes all spaces, and non-alphanumeric charaters, also allows underscores
  # Used mainly for new_vm_filename()

  STRING="$@"
  CLEAN=${STRING// /}
  CLEAN=${CLEAN//[^a-zA-Z0-9_]/}
  output_sanatized="$CLEAN"
  export output_sanatized
  return $?

}


function new_vm_filename(){

  # Naming scheme for the new VM spec file: type_alias_(link)(vnics).json
  #
  # (e.g. os__elasticdb__elastic0eshard0.json, kvm__win__nat0external0__sql0internal0.json)
  # All text will run though text_sanitize(); only characters allowed are regex [a-zA-Z0-9_]

  text_sanitize "$1"
  CHOMP="$output_sanatized"

  if [ -z "$CHOMP" ]; then VM_FILENAME=""; export VM_FILENAME; return $?; fi
  if [ -z "$VM_FILENAME" ]; then VM_FILENAME="$CHOMP"; export VM_FILENAME; return $?; fi
  if [ ! -z "$VM_FILENAME" ]; then VM_FILENAME="$VM_FILENAME"__"$CHOMP"; export VM_FILENAME; return $?; fi
  if [ "$CHOMP" == ".json" ]; then VM_FILENAME="$VM_FILENAME".json; export VM_FILENAME; return $?; fi
  export NEW_VM="$SPECS_DIR/$VM_FILENAME"
  return $?

}
























function spec_brand(){

  cat >> $TEMP << EOF
  "brand": "kvm"
EOF
  return $?

}

function spec_alias(){

  cat >> $TEMP << EOF
  "alias": "$ALIAS",
EOF
  return $?

}

function spec_autoboot(){

  #  global: autoboot
  #    Boolean indicating that a zone should be booted automatically at
  #    system boot.  Note that if the zones service is disabled, the zone
  #    will not autoboot, regardless of the setting of this property. You
  #    enable the zones service with a svcadm command, such as:
  #
  #      svcadm enable svc:/system/zones:default


  cat >> $TEMP << EOF
  "autoboot": $AUTOBOOT,
EOF
  return $?

}

function spec_oslx_ram(){

  #  global: max_physical_memory
  #    The maximum amount of memory on the host that the VM is allowed to use.
  #    For KVM VMs, this value cannot be lower than ram and should be
  #    ram + 1024.

  cat >> $TEMP << EOF
"max_physical_memory": $MAX_MEM_IN_MB,
EOF

}

function spec_oslx_cpu(){

  #  global: cpu_cap
  #    Sets a limit on the amount of CPU time that can be used by a VM. The
  #    unit used is the percentage of a single CPU that can be used by the VM.
  #    Eg. a value of 300 means up to 3 full CPUs.

  default=100

  echo "Number of CPUs (a value of 300 means up to 3 full CPUs):"
  select CPU_CAP in "100" "200" "300" "400" "Custom"; do
    case $CPU_CAP in
      100) CPU_CAP=100; break;;
      200) CPU_CAP=200; break;;
      300) CPU_CAP=300; break;;
      400) CPU_CAP=400; break;;
      Custom) read -p "Set custom CPU value: " CPU_CAP; break;;
    esac
  done
  echo "[*] cpu_cap: $CPU_CAP"
  cat >> $TEMP << EOF
"cpu_cap": $CPU_CAP,
EOF
  return $?

}

function spec_oslx_disk(){

  #  global: quota
  #    This sets a quota on the zone filesystem. For OS VMs, this value is the
  #    space actually visible/usable in the guest. For KVM VMs, this value is
  #    the quota for the Zone containing the VM, which is not directly
  #    available to users.
  #
  #    Set quota to 0 to disable (ie. for no quota).

  # Need to add: spec_delegate_dataset


  default=0



  cat >> $TEMP << EOF
  "quota": "$DISK_IN_GiB",
EOF

}

function spec_kvm_ram(){

  cat >> $TEMP << EOF
  "ram": $RAM_IN_MB,
EOF

}

function spec_kvm_cpu(){

  cat >> $TEMP << EOF
  "vcpus": "$VCPU",
EOF

}

function spec_kvm_disk(){

  select KVM_DISK_TYPE in "Blank: New empty disk" "Image: Disk from an image"; do
    case $KVM_DISK_TYPE in
    "Blank: New empty disk") KVM_DISK_TYPE=blank; break;;
    "Image: Disk from an image") KVM_DISK_TYPE=image; break;;
    esac
  done


  echo "Will this be the boot disk?"
  select BOOTABLE in "Yes" "No"; do
    case $BOOTABLE in
      Yes)BOOTABLE=true; break;;
      No)BOOTABLE=false; break;;
    esac
  done
  
  echo "Select disk model"
  select DISK_MODEL in "virtio (default)" "ide" "scsi"; do
    case $DISK_MODEL in
      "virtio (default)") DISK_MODEL=virtio; break;;
      ide) DISK_MODEL=ide; break;;
      scsi) DISK_MODEL=scsi; break;;
    esac
  done
  
  echo "Select compression"
  select COMPRESSION in "on (default)" "off" "lzjb" "gzip" "gzip-N" "zle"; do
    case $COMPRESSION in
      "on (default)") COMPRESSION=on; break;;
      off) COMPRESSION=off; break;;
      lzjb) COMPRESSION=lzjb; break;;
      gzip) COMPRESSION=gzip; break;;
      gzip-N) COMPRESSION="gzip-N"; break;;
      zle) COMPRESSION=zle; break;;
    esac
  done  

  if [ "$KVM_DISK_TYPE" == blank ]; then
  echo "Disk size (in MB)"
  select DISK_SIZE in "40960 (default)" "30720" "20480" "10240" "Custom"; do
    case $DISK_SIZE in
      "40960 (default)") DISK_SIZE=40960; break;;
      30720) DISK_SIZE=30720; break;;
      20480) DISK_SIZE=20480; break;;
      10240) DISK_SIZE=10240; break;;
      Custom) read -p "Enter disk size (in MB): " DISK_SIZE; break;;
    esac
  done
  # Set zfs quota automatically from disk size
  QUOTA=$(($DISK_SIZE / 1024))
  fi



  if [ "$KVM_DISK_TYPE" == image ]; then
  echo "Set disk usage by image (in MB)"
  select IMAGE_SIZE in "40960 (default)" "30720" "20480" "10240" "Custom"; do
    case $IMAGE_SIZE in
      "40960 (default)") IMAGE_SIZE=40960; break;;
      30720) IMAGE_SIZE=30720; break;;
      20480) IMAGE_SIZE=20480; break;;
      10240) IMAGE_SIZE=10240; break;;
      Custom) read -p "Enter disk size (in MB): " IMAGE_SIZE; break;;
    esac
  done
  # Set zfs quota automatically from disk size
  QUOTA=$(($IMAGE_SIZE / 1024))
  fi




  if [ "$KVM_DISK_TYPE" == blank ]; then
    cat >> $TEMP << EOF
  "disks": [
    {
      "boot": $BOOTABLE,
      "model": "$DISK_MODEL",
      "compression": "$COMPRESSION",
      "size": $DISK_SIZE,
      "quota": "$QUOTA"
      }
  ],
EOF
  fi

  if [ "$KVM_DISK_TYPE" == image ]; then
    cat >> $TEMP << EOF
  "disks": [
    {
      "boot": $BOOTABLE,
      "model": "$DISK_MODEL",
      "compression": "$COMPRESSION",
      "image_uuid": "$IMAGE_UUID",
      "image_name": "$IMAGE_NAME",
      "image_size": 5120,
      "quota": "number in GiB",
      }
  ],
EOF
  fi

  echo "Add another Disk?"
  select ANSWER in "Yes" "No (default)"; do
    case $ANSWER in
      "Yes") spec_kvm_disk; break;;
      "No (default)") break;;
    esac
  done
  return $?

}


function spec_dns(){

  #  global: resolvers
  #    For OS VMs, this value sets the resolvers which get put into
  #    /etc/resolv.conf at VM creation. If maintain_resolvers is set to
  #    true, updating this property will also update the resolvers in
  #    /etc/resolv.conf. For KVM VMs these will get passed as the resolvers
  #    with DHCP responses.

  default=(8.8.8.8 8.8.4.4)

echo "Select a DNS"
select DNS in "8.8.8.8, 8.8.4.4" "Custom"; do
    case $DNS in
      "8.8.8.8, 8.8.4.4") DNS_PRIMARY="8.8.8.8"; DNS_SECONDARY="8.8.4.4"; break;;
      Custom) read -p "Set Primary DNS (8.8.8.8): " DNS_PRIMARY
      read -p "Set Secondary DNS (8.8.4.4): " DNS_SECONDARY

      if [ -z "$DNS_PRIMARY" ]; then DNS_PRIMARY="${default[0]}"; fi
      if [ -z "$DNS_SECONDARY" ]; then DNS_SECONDARY="${default[1]}"; fi

    # Input sanitization
    #      while true; do
    #      read -p "Set Primary DNS: " DNS_PRIMARY
    #      read -p "Set Secondary DNS: " DNS_SECONDARY
    #
    #      echo "$DNS_PRIMARY" | grep -E "[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}"
    #      echo "$DNS_SECONDARY" | grep -E "[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}"
    #
    #      break
    #      done
      break;;
    esac
done

echo "[*] DNS: $DNS_PRIMARY, $DNS_SECONDARY"

  cat >> $TEMP << EOF
  "resolvers": [
    "$DNS_PRIMARY",
    "$DNS_SECONDARY"
  ],
EOF

}

function spec_nics(){

  #  global: interface
  #    Name of the interface within the VM ("eth0")
  #
  #  global: nic_tag
  #    nic_tag or interface name that the virtual NIC is attached to
  #
  #  KVM: model
  #    Driver for this NIC (virtio, e1000, rtl8139)
  #
  #  global: ip
  #    IPv4 Address for NIC, or "dhcp"
  #
  #  global: gateway
  #    Gateway for NIC
  #
  #  global: netmask
  #    Netmask for NIC
  #
  #  global: primary
  #    Sets this NICs gateway as the default gw
  #
  #  global: dhcp_server
  #    Allow the VM on this NIC to act as a DHCP Server
  #
  #  allow_dhcp_spoofing
  #  allow_ip_spoofing
  #  allow_mac_spoofing
  #  allow_restricted_traffic
  #  allow_unfiltered_promisc
  #  blocked_outgoing_ports


  INTERFACE=eth0
  NICTAG=external
  IPADDRESS=unset
  GATEWAY=unset
  NETMASK=unset
  PRIMARY=unset


  while true; do
    read -p "Set VM internal NIC name (eth0): " INTERFACE
    if [ -z "$INTERFACE" ]; then INTERFACE="eth0"; fi

    nictagadm list
    echo ""
    read -p "Set NIC Tag (external): " NICTAG
    if [ -z "$NICTAG" ]; then NICTAG="external"; fi

    echo "Set NIC as default gw?"
    select ANSWER in "Yes (default)" "No"; do
      case $ANSWER in
        "Yes (default)") PRIMARY=true; break ;;
        "No") PRIMARY=false; break ;;
      esac
    done

    select ANSWER in "DHCP (default)" "Static"; do
      case $ANSWER in
        "DHCP (default)")
          IPADDRESS=dhcp
          GATEWAY=dhcp
          NETMASK=dhcp
          break
        ;;
        "Static")
          read -p "IPv4: " IPADDRESS
          if [ -z "$IPADDRESS" ]; then echo Try again; break; fi

          read -p "Gateway: " GATEWAY
          if [ -z "$GATEWAY" ]; then echo Try again; break; fi

          read -p "Netmask (255.255.255.0): " NETMASK
          if [ -z "$NETMASK" ]; then NETMASK="255.255.255.0"; fi

          break
        ;;
      esac
    done

    if [ "$TYPE" == kvm ]; then
      echo "Choose NIC Model: (virtio: best performance, but needs drivers; e1000 & rtl8139: more universal) "
      select ANSWER in "virtio (default)" "e1000" "rtl8139"; do
        case $ANSWER in
          "virtio (default)") NICMODEL="virtio"; break;;
          e1000) NICMODEL="e1000"; break;;
          rtl8139) NICMODEL="rtl8139"; break;;
        esac
      done
    fi

    echo ""
    echo "== Current settings =="
    echo ">> Interface:" "$INTERFACE"
    echo ">> NIC Tag:" "$NICTAG"
    echo ">> IPv4:" "$IPADDRESS"
    echo ">> Gateway:" "$GATEWAY"
    echo ">> Netmask:" "$NETMASK"
    echo ">> Primary NIC:" "$PRIMARY"
    echo ""
    echo "Confirm?"
    select ANSWER in "Done" "There's something wrong"; do
      case $ANSWER in
        "Done") FINISHED="true"; break;;
        "There's something wrong") FINISHED="false"; break;;
      esac
    done

  if [ "$FINISHED" == true ]; then break; fi
  done



  if [ $TYPE == os ]; then
  cat >> $TEMP << EOF
  "nics": [
    {
      "interface": "$INTERFACE",
      "nic_tag": "$NICTAG",
      "ip": "$IPADDRESS",
      "gateway": "$GATEWAY",
      "netmask": "$NETMASK",
      "primary": $PRIMARY
    }
  ],
EOF
  fi

  if [ $TYPE == lx ]; then
  cat >> $TEMP << EOF
  "nics": [
    {
      "interface": "$INTERFACE",
      "nic_tag": "$NICTAG",
      "ip": "$IPADDRESS",
      "gateway": "$GATEWAY",
      "netmask": "$NETMASK",
      "primary": $PRIMARY
    }
  ],
EOF
  fi

  if [ ! $TYPE == kvm ]; then
  cat >> $TEMP << EOF
  "nics": [
    {
      "interface": "$INTERFACE",
      "nic_tag": "$NICTAG",
      "model": "$NICMODEL",
      "ip": "$IPADDRESS",
      "gateway": "$GATEWAY",
      "netmask": "$NETMASK",
      "primary": $PRIMARY
    }
  ],
EOF
  fi

  echo "Add another NIC?"
  select ANSWER in "Yes" "No (default)"; do
    case $ANSWER in
      "Yes") spec_nics; break;;
      "No (default)") break;;
    esac
  done
  return $?

}







function os(){

  spec_brand
  spec_alias
  spec_autoboot
  spec_oslx_ram
  spec_oslx_cpu
  spec_oslx_disk
  return $?

}

function lx(){

  spec_brand
  spec_alias
  spec_autoboot
  spec_oslx_ram
  spec_oslx_cpu
  spec_oslx_disk
  return $?

}

function kvm(){

  spec_brand
  spec_alias
  spec_autoboot
  spec_kvm_ram
  spec_kvm_cpu
  spec_kvm_disks
  return $?

}






function vmadm_validate(){

  # Validates the new vm spec before renaming to $VM_FILENAME
  vmadm validate create -f "$TEMP" >/dev/null 2>/dev/null
  # exit code check
  if [ $? == 0 ]; then echo "[*] JSON Validated"; mv "$TEMP" "$NEW_VM"; return $?; fi
  if [ $? -gt 0 ]; then echo "[ERROR] Validating $TEMPSPEC"; exit 0; fi
  return $?

}

function create_vm_os(){

  # Create OS zone VM
  vmadm create << EOF
{
  "nics": [{"interface": "$INTERNAL_IF_NAME", "nic_tag": "$NICTAG", "model": "$NICMODEL", "ip": "$IPADDRESS", "gateway": "$GATEWAY", "netmask": "$NETMASK", "primary": $PRIMARY}],
  "resolvers": ["$DNS_PRIMARY", "$DNS_SECONDARY"],
  "image_uuid": "$IMAGE_IMPORT_UUID",
  "quota": "$DISK_IN_GiB",
  "cpu_cap": $CPU_CAP,
  "max_physical_memory": $MAX_MEM_IN_MB,
  "autoboot": $AUTOBOOT,
  "alias": "$ALIAS",
  "brand": "joyent"
}
EOF
  return $?

}


function create_vm_lx(){

  # Create LX VM
  vmadm create << EOF
{
  "nics": [{"interface": "$INTERNAL_IF_NAME", "nic_tag": "$NICTAG", "model": "$VIRTIO_E1000_RTL8139", "ip": "$IPADDRESS", "gateway": "$GATEWAY", "netmask": "$NETMASK", "primary": $PRIMARY}],
  "resolvers": ["$DNS_PRIMARY", "$DNS_SECONDARY"],
  "image_uuid": "$IMAGE_IMPORT_UUID",
  "quota": "$DISK_IN_GiB",
  "cpu_cap": $CPU_CAP,
  "max_physical_memory": $MAX_MEM_IN_MB,
  "autoboot": $TRUE_FALSE,
  "alias": "$ALIAS",
  "kernel_version": "3.13.0",
  "brand": "lx"
}
EOF
  return !?

}


function create_vm_kvm(){

  # Create KVM VM
  vmadm create << EOF
{


}
EOF
  return $?

}


function create_vm_iso(){

  # Create ISO VM
  vmadm create << EOF
{
  "nics": [{"interface": "$INTERFACE", "nic_tag": "$NICTAG", "model": "$VIRTIO_E1000_RTL8139", "ip": "$IPADDRESS", "gateway": "$GATEWAY", "netmask": "$NETMASK", "primary": true}],
  "resolvers": ["$DNS_PRIMARY", "$DNS_SECONDARY"],
  "disks": [{"boot": $BOOTABLE,"model": "$DISK_MODEL","size": $DISK_IN_MB,"compression": "$COMPRESSION"}],
  "vcpus": "$VCPU",
  "ram": $RAM_IN_MB,
  "autoboot": $AUTO_BOOT,
  "alias": "$ALIAS",
  "brand": "kvm"
}
EOF

}


function create_vm_spec_kvm_image_import(){

  # Required:
  # $importedUUID

  # Create KVM VM from Imported Image
  vmadm create << EOF
{
  "brand": "kvm",
  "resolvers": ["$DNS_PRIMARY","$DNS_SECONDARY"],
  "ram": "$RAM",
  "max_locked_memory": "$RAM_MAX",
  "vcpus": "$VCPU",
  "nics": [
    {
      "nic_tag": "admin",
      "model": "virtio",
      "ip": "dhcp",
      "primary": true
    }
  ],
  "disks": [
    {
      "image_uuid": "$importedUUID",
      "boot": true,
      "model": "virtio"
    }
  ]
}
EOF

}



# MAIN

pre_check

echo "How would you like to create your VM today?"
select ANSWER in "Just the simple essentials!" "I want to see all the options!"; do
    case $ANSWER in
        "Just the simple essentials!") _EasyTiger EASY
        # Choose VM type
        # Choose DHCP or Static, nic tag
        #
        ;;
        "I want to see all the options!") _EasyTiger HARD
        # Choose VM type
        # Choose DHCP or Static, phys, nic tag, interface, etherstub, vnic
        #  - all ipadm ifprop, addrprop, and prop
        #
        ;;
    esac
done
