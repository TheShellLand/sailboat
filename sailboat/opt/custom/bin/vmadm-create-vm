#!/bin/sh
# SmartOS script creating VMs
#
# Provides an easy to use script for creating LX, OS, and KVM zones
# This de-encumbers the use of manual typing and creates json vm spec automatically
# Also, I stopped wanting to refer to an endless number of json files for figuring out what options to use for which
#  type of VM I was creating
#
#
# alpha0.1
# 0xB4AE7C4C
#


function _EasyTiger(){

  export DIFFICULTY=$1

  choose_vm_type
  return $?

}


function pre_check(){

  # Location for new VM specs
  SPECS_DIR="/opt/custom/json/SAVED_CUSTOM_VM"
  export SPECS_DIR
  echo "[*] New specs located in: $SPECS_DIR"
  if [ ! -d "$SPECS_DIR" ]; then mkdir -p "$SPECS_DIR"; fi

  # New temp file
  pre_check_temp
  return $?

}
function pre_check_temp(){

  # New temp filename
  TEMPSPEC="$(uuid).temp.json"
  export TEMPSPEC
  TEMP="$SPECS_DIR/$TEMPSPEC"
  export TEMP
  return $?

}


function choose_vm_type(){

  # LX, OS, or KVM
  echo "Select a VM type"
  select BRAND in "OS - Native, allows RAM over provisioning" "LX - Native, runs linux flavors, yum" "KVM - Linux image" "ISO - Windows, Linux, Mac, any ISO"; do
    case $BRAND in
      "OS - Native, allows RAM over provisioning") create_vm os ; return $? ;;
      "LX - Native, runs linux flavors, yum") create_vm lx; return $? ;;
      "KVM - Linux image") create_vm kvm; return $? ;;
      "ISO - Windows, Linux, Mac, any ISO") create_vm iso; return $? ;;
    esac
  done
  return $?

}


function create_vm(){

  BRAND="$1"
  export BRAND

  if [ "$BRAND" == "os" ]; then create_vm_os; return $?; fi
  if [ "$BRAND" == "lx" ]; then create_vm_lx; return $?; fi
  if [ "$BRAND" == "iso" ]; then create_vm_iso; return $?; fi
  if [ "$BRAND" == "kvm" ]; then create_vm_kvm; return $?; fi
  return $?

}


function text_sanitize(){

  # Sanatizes input, removes all spaces, and non-alphanumeric charaters, also allows underscores
  # Used mainly for new_vm_filename()

  STRING="$@"
  CLEAN=${STRING// /}
  CLEAN=${CLEAN//[^a-zA-Z0-9_]/}
  output_sanatized="$CLEAN"
  export output_sanatized
  return $?

}


function new_vm_filename(){

  # Naming scheme for the new VM spec file: $BRAND_$ALIAS_(link)(vnics).json
  #
  # (e.g. os__elasticdb__elastic0eshard0.json, kvm__win__nat0external0__sql0internal0.json)
  # All text will run though text_sanitize(); only characters allowed are regex [a-zA-Z0-9_]

  text_sanitize "$1"
  CHOMP="$output_sanatized"

  if [ -z "$CHOMP" ]; then VM_FILENAME=""; export VM_FILENAME; return $?; fi
  if [ -z "$VM_FILENAME" ]; then VM_FILENAME="$CHOMP"; export VM_FILENAME; return $?; fi
  if [ ! -z "$VM_FILENAME" ]; then VM_FILENAME="$VM_FILENAME"__"$CHOMP"; export VM_FILENAME; return $?; fi
  if [ "$CHOMP" == ".json" ]; then VM_FILENAME="$VM_FILENAME".json; export VM_FILENAME; return $?; fi
  export NEW_VM="$SPECS_DIR/$VM_FILENAME"
  return $?

}
























function spec_brand(){

  #  global: brand
  #    This will be one of 'joyent' or 'joyent-minimal' for OS virtualization
  #    and 'kvm' for full hardware virtualization. This is a required value
  #    for VM creation.
         
  cat >> $TEMP << EOF
  "brand": "$BRAND",
EOF
  return $?

}

function spec_alias(){

  #  global: alias
  #    An alias for a VM which is for display/lookup purposes only. Not
  #    required to be unique.

  default=$(date +%s)

  read -p "Set VM name (epoch: $default): " ALIAS
  if [ -z "$ALIAS" ]; then ALIAS=created-$default; fi
  cat >> $TEMP << EOF
  "alias": "$ALIAS",
EOF
  return $?

}

function spec_hostname(){

  #  global: hostname
  #    For KVM VMs, this value will be handed out via DHCP as the hostname for
  #    the VM. For OS VMs, this value will get set in several files at
  #    creation time, but changing it later will do nothing.

  read -p "" HOSTNAME
  cat >> $TEMP << EOF
  "hostname": "$HOSTNAME",
EOF
  return $?

}


function spec_autoboot(){

  #  global: autoboot
  #    Boolean indicating that a zone should be booted automatically at
  #    system boot.  Note that if the zones service is disabled, the zone
  #    will not autoboot, regardless of the setting of this property. You
  #    enable the zones service with a svcadm command, such as:
  #
  #      svcadm enable svc:/system/zones:default

  default=false

  echo "Autoboot if SmartOS reboots? (This will crash the server if it runs out of resources!!)"
  select AUTOBOOT in "Yes" "No"; do
    case $AUTOBOOT in
      Yes) AUTOBOOT=true; break;;
      No) AUTOBOOT=false; break;;
    esac
  done
  cat >> $TEMP << EOF
  "autoboot": $AUTOBOOT,
EOF
  return $?

}

function spec_oslx_ram(){

  #  global: max_physical_memory
  #    The maximum amount of memory on the host that the VM is allowed to use.
  #    For KVM VMs, this value cannot be lower than ram and should be
  #    ram + 1024.

  default=128

  echo ::memstat | mdb -k
  echo ""
  echo "Select max RAM usage (in MB)"
  select RAM_MAX in "128" "256" "512" "1024" "2048" "4096" "Custom"; do
    case $RAM_MAX in
      128) RAM_MAX=128; break;;
      256) RAM_MAX=256; break;;
      512) RAM_MAX=512; break;;
      1024) RAM_MAX=1024; break;;
      2048) RAM_MAX=2048; break;;
      4096) RAM_MAX=4096; break;;
      Custom) read -p "Custom max RAM usage: " RAM_MAX
      if [ -z "$RAM_MAX" ]; then RAM_MAX="$default"; fi
      break;;
    esac
  done
  cat >> $TEMP << EOF
  "max_physical_memory": $RAM_MAX,
EOF
  return $?

}

function spec_oslx_cpu(){

  #  global: cpu_cap
  #    Sets a limit on the amount of CPU time that can be used by a VM. The
  #    unit used is the percentage of a single CPU that can be used by the VM.
  #    Eg. a value of 300 means up to 3 full CPUs.

  # OS VMs see all of the real CPUs, not some subset of them.
  # But scheduling reduces them to some set of their caps and shares.

  default=100

  echo "Select number of CPUs (a value of 300 means up to 3 full CPUs):"
  select CPU_CAP in "100 (default)" "200" "300" "400" "Custom"; do
    case $CPU_CAP in
      "100 (default)") CPU_CAP=100; break;;
      200) CPU_CAP=200; break;;
      300) CPU_CAP=300; break;;
      400) CPU_CAP=400; break;;
      Custom) read -p "Custom CPU value (100): " CPU_CAP
      if [ -z "$CPU_CAP" ]; then CPU_CAP="$default"; fi
      break;;
    esac
  done
  cat >> $TEMP << EOF
  "cpu_cap": $CPU_CAP,
EOF
  return $?

}

function spec_oslx_disk(){

  #  global: quota
  #    This sets a quota on the zone filesystem. For OS VMs, this value is the
  #    space actually visible/usable in the guest. For KVM VMs, this value is
  #    the quota for the Zone containing the VM, which is not directly
  #    available to users.
  #
  #    Set quota to 0 to disable (ie. for no quota).

  # Need to add: spec_delegate_dataset

  default=5

  echo "Select disk size (in GB)"
  select QUOTA in "5 (default)" "10" "15" "20" "25" "30" "40" "Custom"; do
    case $QUOTA in
      "5 (default)") QUOTA=5; break;;
      10) QUOTA=10; break;;
      15) QUOTA=15; break;;
      20) QUOTA=20; break;;
      25) QUOTA=25; break;;
      30) QUOTA=30; break;;
      40) QUOTA=40; break;;
      Custom) read -p "Custom disk size (in GB) (5): " QUOTA
      if [ -z "$QUOTA" ]; then QUOTA="$default"; fi
      break;;
    esac
  done
  cat >> $TEMP << EOF
  "quota": "$QUOTA",
EOF
  return $?

}

function spec_lx_kernel(){

  #  lx: kernel_version
  #    This sets the version of Linux to emulate for LX VMs

  echo "Select kernel version (setting an unsupported kernel version may cause instabilities in the VM)"
  select KERNEL_VERSION in "3.13.0" "Custom"; do
    case $KERNEL_VERSION in
      "3.13.0") KERNEL_VERSION="3.13.0"; break;;
      Custom) read -p "Custom kernel version (3.13.0): " KERNEL_VERSION
      if [ -z "$KERNEL_VERSION" ]; then KERNEL_VERSION="3.13.0"; fi
      break;;
    esac
  done

  cat >> $TEMP << EOF
  "kernel_version": "3.13.0",
EOF
  return $?

}

function spec_kvm_ram(){

  #  KVM: ram
  #    For KVM VMs this is the amount of virtual RAM that will be available to
  #    the guest kernel. For OS VMs this will be the same as the property
  #    max_physical_memory.

  default=512

  echo ::memstat | mdb -k
  echo ""
  echo "Select amount of RAM (in MB)"
  select RAM in "128" "256" "512" "1024" "2048" "4096" "5120" "6144" "Custom"; do
    case $RAM in
      128) RAM=128; break;;
      256) RAM=256; break;;
      512) RAM=512; break;;
      1024) RAM=1024; break;;
      2048) RAM=2048; break;;
      4096) RAM=4096; break;;
      5120) RAM=5120; break;;
      6144) RAM=6144; break;;
      Custom) read -p "Custom RAM (512): " RAM
        if [ -z "$RAM" ]; then RAM="$default"; fi
      break;;
    esac
  done
  cat >> $TEMP << EOF
  "ram": $RAM,
EOF
  return $?

}

function spec_kvm_cpu(){

  # KVM: vcpus
  #   KVM instances that says how many VCPUs they can see
  #   Which is independent of how much CPU the zone can actually use

  default=1

  echo "Select number of CPUs (Be sure not to use more cores than are available)"
  select VCPU in "1" "2" "3" "4" "Custom"; do
    case $VCPU in
      1) VCPU=1; break;;
      2) VCPU=2; break;;
      3) VCPU=3; break;;
      4) VCPU=4; break;;
      Custom) read -p "Custom VCPUS (1): " VCPU
      if [ -z "$VCPU" ]; then VCPU="$default"; fi
      break;;
    esac
  done
  cat >> $TEMP << EOF
  "vcpus": "$VCPU",
EOF
  return $?

}

function spec_kvm_disk(){

  #  KVM: disks.*.<property>
  #    When creating a KVM VM or getting a KVM VM's JSON, you will use this
  #    property. This is an array of 'disk' objects.

  default=blank

  echo "Select disk type"
  select KVM_DISK_TYPE in "Blank: New empty disk" "Image: Disk from an image"; do
    case $KVM_DISK_TYPE in
    "Blank: New empty disk") KVM_DISK_TYPE=blank; break;;
    "Image: Disk from an image") KVM_DISK_TYPE=image; break;;
    esac
  done

  echo "Will this be the boot disk?"
  select BOOTABLE in "Yes" "No"; do
    case $BOOTABLE in
      Yes) BOOTABLE=true; break;;
      No) BOOTABLE=false; break;;
    esac
  done
  
  echo "Select disk model"
  select DISK_MODEL in "virtio (default)" "ide" "scsi"; do
    case $DISK_MODEL in
      "virtio (default)") DISK_MODEL=virtio; break;;
      ide) DISK_MODEL=ide; break;;
      scsi) DISK_MODEL=scsi; break;;
    esac
  done
  
  echo "Select compression"
  select COMPRESSION in "on (default)" "off" "lzjb" "gzip" "gzip-N" "zle"; do
    case $COMPRESSION in
      "on (default)") COMPRESSION=on; break;;
      off) COMPRESSION=off; break;;
      lzjb) COMPRESSION=lzjb; break;;
      gzip) COMPRESSION=gzip; break;;
      gzip-N) COMPRESSION="gzip-N"; break;;
      zle) COMPRESSION=zle; break;;
    esac
  done  

  if [ "$KVM_DISK_TYPE" == blank ]; then
  echo "Select disk size (in MB)"
  select DISK_SIZE in "5120" "10240" "20480" "30720" "40960" "Custom"; do
    case $DISK_SIZE in
      5120) DISK_SIZE=5120; break;;
      10240) DISK_SIZE=10240; break;;
      20480) DISK_SIZE=20480; break;;
      30720) DISK_SIZE=30720; break;;
      40960) DISK_SIZE=40960; break;;
      Custom) read -p "Custom disk size (in MB) (10240): " DISK_SIZE
      if [ -z "$DISK_SIZE" ]; then DISK_SIZE=10240; fi
      break;;
    esac
  done
    # Set zfs quota automatically from disk size
    QUOTA=$(($DISK_SIZE / 1024 + 1))
  fi

  if [ "$KVM_DISK_TYPE" == image ]; then
  echo "Select max disk allocation (in MB)"
  select IMAGE_SIZE in "10240" "20480" "30720" "40960" "Custom"; do
    case $IMAGE_SIZE in
      10240) IMAGE_SIZE=10240; break;;
      20480) IMAGE_SIZE=20480; break;;
      30720) IMAGE_SIZE=30720; break;;
      40960) IMAGE_SIZE=40960; break;;
      Custom) read -p "Custom disk size (in MB): " IMAGE_SIZE; break;;
    esac
  done
    # Set zfs quota automatically from disk size
    QUOTA=$(($IMAGE_SIZE / 1024))
  fi



  if [ "$KVM_DISK_TYPE" == blank ]; then
    cat >> $TEMP << EOF
  "disks": [
    {
      "boot": $BOOTABLE,
      "model": "$DISK_MODEL",
      "compression": "$COMPRESSION",
      "size": $DISK_SIZE,
      "quota": "$QUOTA"
      }
  ],
EOF
  fi

  if [ "$KVM_DISK_TYPE" == image ]; then
    cat >> $TEMP << EOF
  "disks": [
    {
      "boot": $BOOTABLE,
      "model": "$DISK_MODEL",
      "compression": "$COMPRESSION",
      "image_uuid": "$IMAGE_UUID",
      "image_name": "$IMAGE_NAME",
      "image_size": $IMAGE_SIZE,
      "quota": "$QUOTA"
      }
  ],
EOF
  fi

  echo "Add another Disk?"
  select ANSWER in "Yes" "No (default)"; do
    case $ANSWER in
      "Yes") spec_kvm_disk; break;;
      "No (default)") break;;
    esac
  done
  return $?

}

function spec_nics(){

  #  global: interface
  #    Name of the interface within the VM ("eth0")
  #
  #  global: nic_tag
  #    nic_tag or interface name that the virtual NIC is attached to
  #
  #  KVM: model
  #    Driver for this NIC (virtio, e1000, rtl8139)
  #
  #  global: ip
  #    IPv4 Address for NIC, or "dhcp"
  #
  #  global: gateway
  #    Gateway for NIC
  #
  #  global: netmask
  #    Netmask for NIC
  #
  #  global: primary
  #    Sets this NICs gateway as the default gw
  #
  #  global: dhcp_server
  #    Allow the VM on this NIC to act as a DHCP Server
  #
  #  allow_dhcp_spoofing
  #  allow_ip_spoofing
  #  allow_mac_spoofing
  #  allow_restricted_traffic
  #  allow_unfiltered_promisc
  #  blocked_outgoing_ports


  INTERFACE=eth0
  NICTAG=external
  IPADDRESS=unset
  GATEWAY=unset
  NETMASK=unset
  PRIMARY=unset


  while true; do
    read -p "Set VM internal NIC name (eth0): " INTERFACE
    if [ -z "$INTERFACE" ]; then INTERFACE=$INTERFACE; fi

    nictagadm list
    echo ""
    read -p "Set NIC Tag (external): " NICTAG
    if [ -z "$NICTAG" ]; then NICTAG=$NICTAG; fi

    echo "Set NIC as default gw?"
    select ANSWER in "Yes (default)" "No"; do
      case $ANSWER in
        "Yes (default)") PRIMARY=true; break ;;
        "No") PRIMARY=false; break ;;
      esac
    done

    select ANSWER in "DHCP (default)" "Static"; do
      case $ANSWER in
        "DHCP (default)")
          IPADDRESS=dhcp
          GATEWAY=dhcp
          NETMASK=dhcp
          break
        ;;
        "Static")
          read -p "IPv4: " IPADDRESS
          if [ -z "$IPADDRESS" ]; then echo Try again; break; fi

          read -p "Gateway: " GATEWAY
          if [ -z "$GATEWAY" ]; then echo Try again; break; fi

          read -p "Netmask (255.255.255.0): " NETMASK
          if [ -z "$NETMASK" ]; then NETMASK="255.255.255.0"; fi

          break
        ;;
      esac
    done

    if [ "$BRAND" == kvm ]; then
      echo "Choose NIC Model: (virtio: best performance, but needs drivers; e1000 & rtl8139: more universal) "
      select ANSWER in "virtio (default)" "e1000" "rtl8139"; do
        case $ANSWER in
          "virtio (default)") NICMODEL="virtio"; break;;
          e1000) NICMODEL="e1000"; break;;
          rtl8139) NICMODEL="rtl8139"; break;;
        esac
      done
    fi

    echo ""
    echo "== Current settings =="
    echo ">> Interface:" "$INTERFACE"
    echo ">> NIC Tag:" "$NICTAG"
    echo ">> IPv4:" "$IPADDRESS"
    echo ">> Gateway:" "$GATEWAY"
    echo ">> Netmask:" "$NETMASK"
    echo ">> Primary NIC:" "$PRIMARY"
    echo ""
    echo "Confirm?"
    select ANSWER in "Done" "There's something wrong"; do
      case $ANSWER in
        "Done") FINISHED="true"; break;;
        "There's something wrong") FINISHED="false"; break;;
      esac
    done

  if [ "$FINISHED" == true ]; then break; fi
  done



  if [ "$BRAND" == os ]; then
  cat >> $TEMP << EOF
  "nics": [
    {
      "interface": "$INTERFACE",
      "nic_tag": "$NICTAG",
      "ip": "$IPADDRESS",
      "gateway": "$GATEWAY",
      "netmask": "$NETMASK",
      "primary": $PRIMARY
    }
  ],
EOF
  fi

  if [ "$BRAND" == lx ]; then
  cat >> $TEMP << EOF
  "nics": [
    {
      "interface": "$INTERFACE",
      "nic_tag": "$NICTAG",
      "ip": "$IPADDRESS",
      "gateway": "$GATEWAY",
      "netmask": "$NETMASK",
      "primary": $PRIMARY
    }
  ],
EOF
  fi

  if [ "$BRAND" == kvm ]; then
  cat >> $TEMP << EOF
  "nics": [
    {
      "interface": "$INTERFACE",
      "nic_tag": "$NICTAG",
      "model": "$NICMODEL",
      "ip": "$IPADDRESS",
      "gateway": "$GATEWAY",
      "netmask": "$NETMASK",
      "primary": $PRIMARY
    }
  ],
EOF
  fi

  echo "Add another NIC?"
  select ANSWER in "Yes" "No (default)"; do
    case $ANSWER in
      "Yes") spec_nics; break;;
      "No (default)") break;;
    esac
  done
  return $?

}

function spec_dns(){

  #  global: resolvers
  #    For OS VMs, this value sets the resolvers which get put into
  #    /etc/resolv.conf at VM creation. If maintain_resolvers is set to
  #    true, updating this property will also update the resolvers in
  #    /etc/resolv.conf. For KVM VMs these will get passed as the resolvers
  #    with DHCP responses.

  default=(8.8.8.8 8.8.4.4)

echo "Select a DNS"
select DNS in "8.8.8.8, 8.8.4.4" "Custom"; do
    case $DNS in
      "8.8.8.8, 8.8.4.4") DNS_PRIMARY="8.8.8.8"; DNS_SECONDARY="8.8.4.4"; break;;
      Custom) read -p "Set Primary DNS (8.8.8.8): " DNS_PRIMARY
      read -p "Set Secondary DNS (8.8.4.4): " DNS_SECONDARY

      if [ -z "$DNS_PRIMARY" ]; then DNS_PRIMARY="${default[0]}"; fi
      if [ -z "$DNS_SECONDARY" ]; then DNS_SECONDARY="${default[1]}"; fi

    # Input sanitization
    #      while true; do
    #      read -p "Set Primary DNS: " DNS_PRIMARY
    #      read -p "Set Secondary DNS: " DNS_SECONDARY
    #
    #      echo "$DNS_PRIMARY" | grep -E "[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}"
    #      echo "$DNS_SECONDARY" | grep -E "[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}"
    #
    #      break
    #      done
      break;;
    esac
done

echo "[*] DNS: $DNS_PRIMARY, $DNS_SECONDARY"

  cat >> $TEMP << EOF
  "resolvers": [
    "$DNS_PRIMARY",
    "$DNS_SECONDARY"
  ]
EOF

}





function os(){

  spec_brand
  spec_alias
  spec_hostname
  spec_autoboot
  spec_oslx_ram
  spec_oslx_cpu
  spec_oslx_disk
  spec_nics
  spec_dns
  return $?

}

function lx(){

  spec_brand
  spec_alias
  spec_hostname
  spec_autoboot
  spec_oslx_ram
  spec_oslx_cpu
  spec_oslx_disk
  spec_nics
  spec_dns
  return $?

}

function kvm(){

  spec_brand
  spec_alias
  spec_hostname
  spec_autoboot
  spec_kvm_ram
  spec_kvm_cpu
  spec_kvm_disk
  spec_nics
  spec_dns
  return $?

}


function vmadm_validate(){

  # Validates the new vm spec before renaming to $VM_FILENAME
  vmadm validate create -f "$TEMP" >/dev/null 2>/dev/null
  # exit code check
  if [ $? == 0 ]; then echo "[*] JSON Validated"; mv "$TEMP" "$NEW_VM"; return $?; fi
  if [ $? -gt 0 ]; then echo "[ERROR] Validating $TEMPSPEC"; exit 0; fi
  return $?

}

function vmadm_create(){

  # Create VM from $TEMP
  vmadm create -f "$TEMP"
  return $?

}

function create_vm_os(){

  os
  vmadm_validate
  vmadm_create

  return $?

}


function create_vm_lx(){

  # Create LX VM
  vmadm create << EOF
{
  "image_uuid": "$IMAGE_IMPORT_UUID",



}
EOF
  return $?

}


function create_vm_kvm(){

  kvm
  vmadm_validate
  vmadm_create
  return $?

}


function create_vm_iso(){

  kvm
  vmadm_validate
  vmadm_create

  return $?

}


function create_vm_spec_kvm_image_import(){

  # Required:
  # $importedUUID

  # Create KVM VM from Imported Image
  vmadm create << EOF
{
  "brand": "kvm",
  "resolvers": [
    "$DNS_PRIMARY",
    "$DNS_SECONDARY"
  ],
  "ram": "$RAM",
  "max_locked_memory": "$RAM_MAX",
  "vcpus": "$VCPU",
  "nics": [
    {
      "nic_tag": "admin",
      "model": "virtio",
      "ip": "dhcp",
      "primary": true
    }
  ],
  "disks": [
    {
      "image_uuid": "$importedUUID",
      "boot": true,
      "model": "virtio"
    }
  ]
}
EOF

}



# MAIN

pre_check

echo "How would you like to create your VM today?"
select ANSWER in "Just the simple essentials!" "I want to see all the options!"; do
    case $ANSWER in
        "Just the simple essentials!") _EasyTiger EASY
        # Choose VM type
        # Choose DHCP or Static, nic tag
        #
        ;;
        "I want to see all the options!") _EasyTiger HARD
        # Choose VM type
        # Choose DHCP or Static, phys, nic tag, interface, etherstub, vnic
        #  - all ipadm ifprop, addrprop, and prop
        #
        ;;
    esac
done
